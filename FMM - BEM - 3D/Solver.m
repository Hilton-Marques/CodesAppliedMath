classdef Solver < handle
    properties
        ng
        n
        totN % total number of multipole terms
        Ax % multiplication matrix vector
        ngS = 20; %number of gauss for singularity
        X;
        Y;
        Wx;
        Wy;
    end
    methods
        function this = Solver(ng,n,nNodes)
            this.ng = ng;
            this.n = n;
            %max capacity of moments, remeber that the terms forms a triangle,
            %so the total numbers of terms is Sn = (a + an)n/2
            %Besides that, I also have n + 1 terms
            a1 = 1;
            an = 2*(n)+1;
            this.totN = (a1 + an)*(n+1)/2;
            this.Ax = zeros(nNodes,1);
            [this.X,this.Y,this.Wx,this.Wy] = this.triQuad(this.ngS);
            
        end
        function calculateME(this,leaf)
            [X,Y,Wx,Wy] = this.triQuad;
            yc = leaf.nodeCE;
            for i = 1:leaf.nNodes
                node = leaf.nodes(i);
                element = node.element;
                area = element.area;
                normal = element.n;
                if (element.q(1) == 1)
                    u = element.q(2);  %temperature
                    for o = 1:this.ng
                        for p = 1:this.ng
                            xksi = (1 - X(p,o) - Y(p,o))*element.pos(1,:) + ...
                                X(p,o)*element.pos(2,:) + ...
                                Y(p,o)*element.pos(3,:);
                            r = xksi - yc;
                            Ry = RTable(this.n,r);
                            count = 1;
                            for n = 0:this.n
                                for m = -n:n
                                    dR = [-0.5*( Ry.pos(this.indexNM(n-1,m-1)) - ...
                                        Ry.pos(this.indexNM(n-1,m+1))) , ...
                                        -(complex(0,1)/2) * (Ry.pos(this.indexNM(n-1,m-1)) +...
                                        Ry.pos(this.indexNM(n-1,m+1))), ...
                                        Ry.pos(this.indexNM(n-1,m))];
                                    leaf.MEH(count) = leaf.MEH(count) + ...
                                        (area/0.5)*u*(dR*normal)*Wx(p)*Wy(o);
                                    count = count + 1;
                                end
                            end
                            
                        end
                    end
                else
                    q = element.q(2);
                    count = 1;
                    for n = 0:this.n
                        for m = -n:n
                            for o = 1:this.ng
                                for p = 1:this.ng
                                    xksi = (1 - X(p,o) - Y(p,o))*element.pos(1,:) + ...
                                        X(p,o)*element.pos(2,:) + ...
                                        Y(p,o)*element.pos(3,:);
                                    r = xksi - yc;
                                    leaf.MEG(count) = leaf.MEG(count) + ...
                                        (area/0.5)*q*this.RLook(r,this.indexNM(n,m),n)*Wx(p)*Wy(o);
                                end
                            end
                            count = count + 1;
                        end
                    end
                end
            end
        end
        function calculateM2L(this,cell,field)
            cellTemp = zeros(this.totN,1);
            xs = cell.nodeCE;
            xf = field.nodeCE;
            r = xs - xf;
            count = 1;
            SSb = this.Sb(2*this.n + 1,r,[]);
            for n = 0:this.n
                for m = -n:n
                    for nc = 0:this.n
                        for mc = -nc:nc
                            cell.MLG(count) = cell.MLG(count) + ...
                                ((-1)^n)*SSb(this.indexNM(n+nc, m + mc))*...
                                field.MEG(this.indexNM(nc,mc));
                            cell.MLH(count) = cell.MLH(count) + ...
                                ((-1)^n)*SSb(this.indexNM(n+nc, m + mc))*...
                                field.MEH(this.indexNM(nc,mc));
                        end
                    end
                    count = count + 1;
                end
            end
        end
        function calculateMMT(this,cell)
            children = [cell.children{:}];
            children = children([children(:).nNodes] > 0);
            ycL = cell.nodeCE;
            for i = 1:length(children)
                child = children(i);
                yc = child.nodeCE;
                r = yc - ycL;
                R = this.R(2*this.n + 1,r,[]);
                count = 1;
                for n = 0:this.n
                    for m = -n:n
                        for nc = 0:this.n
                            for mc = -nc:nc
                                id = this.indexNM(n-nc,m-mc);
                                if (id > 0)
                                    cell.MEG(count) = cell.MEG(count) + ...
                                        R(this.indexNM(nc,mc))*...
                                        child.MEG(id);
                                    cell.MEH(count) = cell.MEH(count) + ...
                                        R(this.indexNM(nc,mc))*...
                                        child.MEH(id);
                                end
                            end
                        end
                        count = count + 1;
                    end
                end
            end
        end
        function calculateLLT(this,cell)
            children = [cell.children{:}];
            children = children([children(:).nNodes] > 0);
            xcL = cell.nodeCE;
            for i = 1:length(children)
                child = children(i);
                xc = child.nodeCE;
                r = xc - xcL;
                R = this.R(2*this.n + 1,r,[]);
                count = 1;
                for n = 0:this.n
                    for m = -n:n
                        for nc = 0:this.n
                            for mc = -nc:nc
                                id = this.indexNM(nc -n,mc - m);
                                if (id > 0 )
                                    child.MLG(count) = child.MLG(count) + ...
                                        R(id)*...
                                        cell.MLG(this.indexNM(nc,mc));
                                    child.MLH(count) = child.MLH(count) + ...
                                        R(id)*...
                                        cell.MLH(this.indexNM(nc,mc));
                                end
                            end
                        end
                        count = count + 1;
                    end
                end
            end
        end
        function calculateFarInt(this,cell)
            xl = cell.nodeCE;
            nodes = cell.nodes;
            for i = 1:length(nodes)
                node = nodes(i);
                x = node.pos;
                r = x - xl;
                %R = this.R(this.n+1,r,[]);
                Robj = RTable(this.n+1,r);
                R = Robj.getRow(this.n+1);
                
                this.Ax(node.element.id) = this.Ax(node.element.id) + ...
                    (1/(4*pi))*R*cell.MLG;
                this.Ax(node.element.id) = this.Ax(node.element.id) + ...
                    (1/(4*pi))*R*cell.MLH;
            end
            
        end
        function calculateNearInt(this,source,fields)
            % Get the part inside the cell
            bodiesSource = source.nodes;
            for i = 1:length(bodiesSource)
                bodyS = bodiesSource(i);
                elementS = bodyS.element;
                for j = 1:length(bodiesSource)
                    bodyF = bodiesSource(j);
                    elementF = bodyF.element;
                    if (elementF.q(1) == 1)
                        if (i == j)
                            this.Ax(elementS.id) = this.Ax(elementS.id) + ...
                                0.5*elementF.q(2);
                        else
                            this.Ax(elementS.id) = this.Ax(elementS.id) + ...
                                this.calculateHHd(bodyS.pos,elementF);
                        end
                    else
                        this.Ax(elementS.id) = this.Ax(elementS.id) + ...
                            this.calculateGGq(bodyS.pos,elementF);
                    end
                end
                % Get the part adjacent to cell
                for j = 1:length(fields)
                    field = fields(j);
                    bodiesF = field.nodes;
                    for l = 1:length(bodiesF)
                        bodyF = bodiesF(l);
                        elementF = bodyF.element;
                        if (elementF.q(1) == 1)
                            this.Ax(elementS.id) = this.Ax(elementS.id) + ...
                                this.calculateHHd(bodyS.pos,elementF);
                        else
                            this.Ax(elementS.id) = this.Ax(elementS.id) + ...
                                this.calculateGGq(bodyS.pos,elementF);
                        end
                    end
                end
            end
        end
        
        
        %% Conventional BEM
        function out = calculateHHd(this,source,element)
            out = 0;
            p1 = element.pos(1,:);
            p2 = element.pos(2,:);
            p3 = element.pos(3,:);
            area = element.area;
            u = element.q(2);
            normal = element.n;
            X = this.X; Y = this.Y; Wx = this.Wx; Wy = this.Wy;
            for l = 1:this.ngS
                for k = 1:this.ngS
                    xksi = (1 - X(k,l) - Y(k,l))*p1 + X(k,l)*p2 + Y(k,l)*p3;
                    r = xksi - source;
                    out = out + (-dot(r,normal)/(norm(r)^3))*...
                        Wx(k)*Wy(l);
                end
            end
            out = (u*2*area/(4*pi))*out;
        end
        function out = calculateGGq(this,source,element)
            out = 0;
            p1 = element.pos(1,:);
            p2 = element.pos(2,:);
            p3 = element.pos(3,:);
            area = element.area;
            q = element.q(2);
            [X,Y,Wx,Wy] = this.triQuad(this.ngS);
            for l = 1:this.ngS
                for k = 1:this.ngS
                    xksi = (1 - X(k,l) - Y(k,l))*p1 + X(k,l)*p2 + Y(k,l)*p3;
                    r = xksi - source;
                    out  = out + q*(area/0.5)*(1/(4*pi*norm(r)))*...
                        Wx(k)*Wy(l);
                end
            end
        end
        %% Funções auxiliares
        function out = R(~,n,y,m)
            if n == 1
                out = 1;
                return;
            end
            r2 = dot(y,y);
            %% Initialize Values
            RValues(n) = SphericalHarmonics();
            for i = 1:n
                RValues(i) = SphericalHarmonics(i);
            end
            %% Obtain N,N Values
            RValues(1).addNNValue(1);
            RValues(1).merge();
            for i = 2:n
                Rnn = RValues(i-1).MValuesPos(end);
                value = -Rnn*(y(1) + complex(0,1)*y(2))/(2*(i-1));
                RValues(i).addNNValue(value);
            end
            %% Obtain N,M Values with M => 0
            R10 = y(3)*RValues(1).MValuesPos(1);
            RValues(2).addMValues(R10,1);
            RValues(2).merge();
            for i = 3:n
                obj = RValues(i);
                objAn2 = RValues(i-2);
                objAn1 = RValues(i-1);
                mTot = obj.m;   %Calcule o total de indices m
                mEnd = 1+(mTot-1)/2;  % Calcule quanto tem do centro até a borda
                for j = 1:mEnd-2
                    MValue = (1/(((i-2) + (j-1) + 1)*(i-2 + 1 - (j-1))))*...
                        ( (2*(i-2)+1)*y(3)*objAn1.MValuesPos(j) - ...
                        r2*objAn2.MValuesPos(j) );
                    obj.addMValues(MValue,j);
                end
                j = j + 1;
                MValue = (1/(((i-2) + (j-1) + 1)*(i-2 + 1 - (j-1))))*...
                    (2*(i-2)+1)*y(3)*objAn1.MValuesPos(j);
                obj.addMValues(MValue,j);
                obj.merge();  % Find the negative values of m
            end
            %Quando olhei no mathematica os sinais estavam inversos
            out = RValues(end).values;
            if ~isempty(m)
                out = out(m);
            else
                out = [RValues(:).values];
            end
        end
        function out = Sb(~,n,y,m)
            r = norm(y);
            ir2 = 1/dot(y,y);
            if n == 1
                out = 1/r;
                return;
            end
            %% Initialize Values
            SValues(n) = SphericalHarmonics();
            for i = 1:n
                SValues(i) = SphericalHarmonics(i);
            end
            %% Obtain N,N Values
            SValues(1).addNNValue(1/r);
            SValues(1).merge();
            for i = 2:n
                Snn = SValues(i-1).MValuesPos(end);
                value = -Snn*(2*(i-2)+1)* (y(1) + complex(0,1)*y(2)) *ir2;
                SValues(i).addNNValue(value);
            end
            %% Obtain N,M Values
            S10 = ir2*y(3)*SValues(1).MValuesPos(1);
            SValues(2).addMValues(S10,1);
            SValues(2).merge();
            for i = 3:n
                obj = SValues(i);
                objAn2 = SValues(i-2);
                objAn1 = SValues(i-1);
                mEnd = 1+(obj.m-1)/2;
                for j = 1:mEnd-2
                    MValue = ir2*(-((i-2) + (j-1))*((i-2) - (j-1))*objAn2.MValuesPos(j) + ...
                        (2*(i-2) + 1)*y(3)*objAn1.MValuesPos(j) );
                    obj.addMValues(MValue,j);
                end
                j = j + 1;
                MValue = ir2*(2*(i-2) + 1)*y(3)*objAn1.MValuesPos(j);
                obj.addMValues(MValue,j);
                obj.merge();
            end
            out = [SValues(:).values]';
            if ~isempty(m)
                level = SValues(end).values';
                out = level(m);
            end
        end
        function out = RLook(~,y,pos,n)
            if (pos <= 0 || n < 0)
                out = 0;
                return;
            end
            y1 = y(1);
            y2 = y(2);
            y3 = y(3);
            if n < 5
                Table = {@(y1,y2,y3)1,@(y1,y2,y3)(1/2).*(y1+(sqrt(-1)*(-1)).*y2),@(y1,y2,y3)y3,@(y1,y2,y3)(1/2).*((-1).*y1+(sqrt(-1)*( ...
                    -1)).*y2),@(y1,y2,y3)(1/8).*(y1+(sqrt(-1)*(-1)).*y2).^2,@(y1,y2,y3)(1/2).*(y1+(sqrt(-1)* ...
                    (-1)).*y2).*y3,@(y1,y2,y3)(1/4).*((-1).*y1.^2+(-1).*y2.^2+2.*y3.^2),@(y1,y2,y3)(-1/2).*( ...
                    y1+sqrt(-1).*y2).*y3,@(y1,y2,y3)(1/8).*(y1+sqrt(-1).*y2).^2,@(y1,y2,y3)(1/48).*(y1+( ...
                    sqrt(-1)*(-1)).*y2).^3,@(y1,y2,y3)(1/8).*(y1+(sqrt(-1)*(-1)).*y2).^2.*y3,@(y1,y2,y3)( ...
                    -1/16).*(y1+(sqrt(-1)*(-1)).*y2).*(y1.^2+y2.^2+(-4).*y3.^2),@(y1,y2,y3)(1/12) ...
                    .*((-3).*y1.^2.*y3+(-3).*y2.^2.*y3+2.*y3.^3),@(y1,y2,y3)(1/16).*(y1+sqrt(-1) ...
                    .*y2).*(y1.^2+y2.^2+(-4).*y3.^2),@(y1,y2,y3)(1/8).*(y1+sqrt(-1).*y2).^2.*y3,@(y1,y2,y3)( ...
                    -1/48).*(y1+sqrt(-1).*y2).^3,@(y1,y2,y3)(1/384).*(y1+(sqrt(-1)*(-1)).*y2).^4,@(y1,y2,y3) ...
                    (1/48).*(y1+(sqrt(-1)*(-1)).*y2).^3.*y3,@(y1,y2,y3)(-1/96).*(y1+(sqrt(-1)*( ...
                    -1)).*y2).^2.*(y1.^2+y2.^2+(-6).*y3.^2),@(y1,y2,y3)(-1/48).*(y1+(sqrt(-1)*( ...
                    -1)).*y2).*y3.*(3.*y1.^2+3.*y2.^2+(-4).*y3.^2),@(y1,y2,y3)(1/192).*(3.*y1.^4+ ...
                    3.*y2.^4+(-24).*y2.^2.*y3.^2+8.*y3.^4+6.*y1.^2.*(y2.^2+(-4).* ...
                    y3.^2)),@(y1,y2,y3)(1/48).*(y1+sqrt(-1).*y2).*y3.*(3.*y1.^2+3.*y2.^2+(-4).* ...
                    y3.^2),@(y1,y2,y3)(-1/96).*(y1+sqrt(-1).*y2).^2.*(y1.^2+y2.^2+(-6).*y3.^2),@(y1,y2,y3)( ...
                    -1/48).*(y1+sqrt(-1).*y2).^3.*y3,@(y1,y2,y3)(1/384).*(y1+sqrt(-1).*y2).^4};
            elseif (n >= 5)
                pos = pos - 25;
                Table = {@(y1,y2,y3)(1/3840).*(y1+(sqrt(-1)*(-1)).*y2).^5,@(y1,y2,y3)(1/384).*(y1+(sqrt(-1)*(-1) ...
                    ).*y2).^4.*y3,@(y1,y2,y3)(-1/768).*(y1+(sqrt(-1)*(-1)).*y2).^3.*(y1.^2+y2.^2+ ...
                    (-8).*y3.^2),@(y1,y2,y3)(-1/96).*(y1+(sqrt(-1)*(-1)).*y2).^2.*y3.*(y1.^2+ ...
                    y2.^2+(-2).*y3.^2),@(y1,y2,y3)(1/384).*(y1+(sqrt(-1)*(-1)).*y2).*(y1.^4+ ...
                    y2.^4+(-12).*y2.^2.*y3.^2+8.*y3.^4+2.*y1.^2.*(y2.^2+(-6).*y3.^2)),@(y1,y2,y3) ...
                    (1/960).*y3.*(15.*y1.^4+15.*y2.^4+(-40).*y2.^2.*y3.^2+8.*y3.^4+ ...
                    10.*y1.^2.*(3.*y2.^2+(-4).*y3.^2)),@(y1,y2,y3)(-1/384).*(y1+sqrt(-1).*y2).*( ...
                    y1.^4+y2.^4+(-12).*y2.^2.*y3.^2+8.*y3.^4+2.*y1.^2.*(y2.^2+(-6).* ...
                    y3.^2)),@(y1,y2,y3)(-1/96).*(y1+sqrt(-1).*y2).^2.*y3.*(y1.^2+y2.^2+(-2).* ...
                    y3.^2),@(y1,y2,y3)(1/768).*(y1+sqrt(-1).*y2).^3.*(y1.^2+y2.^2+(-8).*y3.^2),@(y1,y2,y3)( ...
                    1/384).*(y1+sqrt(-1).*y2).^4.*y3,@(y1,y2,y3)(-1/3840).*(y1+sqrt(-1).*y2).^5,@(y1,y2,y3)( ...
                    1/46080).*(y1+(sqrt(-1)*(-1)).*y2).^6,@(y1,y2,y3)(1/3840).*(y1+(sqrt(-1)*(-1) ...
                    ).*y2).^5.*y3,@(y1,y2,y3)(-1/7680).*(y1+(sqrt(-1)*(-1)).*y2).^4.*(y1.^2+ ...
                    y2.^2+(-10).*y3.^2),@(y1,y2,y3)(-1/2304).*(y1+(sqrt(-1)*(-1)).*y2).^3.*y3.*( ...
                    3.*y1.^2+3.*y2.^2+(-8).*y3.^2),@(y1,y2,y3)(1/3072).*(y1+(sqrt(-1)*(-1)).*y2) ...
                    .^2.*(y1.^4+y2.^4+(-16).*y2.^2.*y3.^2+16.*y3.^4+2.*y1.^2.*(y2.^2+( ...
                    -8).*y3.^2)),@(y1,y2,y3)(1/1920).*(y1+(sqrt(-1)*(-1)).*y2).*y3.*(5.*y1.^4+5.* ...
                    y2.^4+(-20).*y2.^2.*y3.^2+8.*y3.^4+10.*y1.^2.*(y2.^2+(-2).*y3.^2)) ...
                    ,@(y1,y2,y3)(1/11520).*((-5).*y1.^6+(-5).*y2.^6+90.*y2.^4.*y3.^2+(-120).* ...
                    y2.^2.*y3.^4+16.*y3.^6+(-15).*y1.^4.*(y2.^2+(-6).*y3.^2)+(-15).* ...
                    y1.^2.*(y2.^4+(-12).*y2.^2.*y3.^2+8.*y3.^4)),@(y1,y2,y3)(-1/1920).*(y1+sqrt( ...
                    -1).*y2).*y3.*(5.*y1.^4+5.*y2.^4+(-20).*y2.^2.*y3.^2+8.*y3.^4+10.* ...
                    y1.^2.*(y2.^2+(-2).*y3.^2)),@(y1,y2,y3)(1/3072).*(y1+sqrt(-1).*y2).^2.*( ...
                    y1.^4+y2.^4+(-16).*y2.^2.*y3.^2+16.*y3.^4+2.*y1.^2.*(y2.^2+(-8).* ...
                    y3.^2)),@(y1,y2,y3)(1/2304).*(y1+sqrt(-1).*y2).^3.*y3.*(3.*y1.^2+3.*y2.^2+( ...
                    -8).*y3.^2),@(y1,y2,y3)(-1/7680).*(y1+sqrt(-1).*y2).^4.*(y1.^2+y2.^2+(-10).* ...
                    y3.^2),@(y1,y2,y3)(-1/3840).*(y1+sqrt(-1).*y2).^5.*y3,@(y1,y2,y3)(1/46080).*(y1+sqrt(-1) ...
                    .*y2).^6,@(y1,y2,y3)(1/645120).*(y1+(sqrt(-1)*(-1)).*y2).^7,@(y1,y2,y3)(1/46080).*(y1+( ...
                    sqrt(-1)*(-1)).*y2).^6.*y3,@(y1,y2,y3)(-1/92160).*(y1+(sqrt(-1)*(-1)).*y2) ...
                    .^5.*(y1.^2+y2.^2+(-12).*y3.^2),@(y1,y2,y3)(-1/23040).*(y1+(sqrt(-1)*(-1)).* ...
                    y2).^4.*y3.*(3.*y1.^2+3.*y2.^2+(-10).*y3.^2),@(y1,y2,y3)(1/92160).*(y1+(sqrt( ...
                    -1)*(-1)).*y2).^3.*(3.*y1.^4+3.*y2.^4+(-60).*y2.^2.*y3.^2+80.* ...
                    y3.^4+6.*y1.^2.*(y2.^2+(-10).*y3.^2)),@(y1,y2,y3)(1/46080).*(y1+(sqrt(-1)*( ...
                    -1)).*y2).^2.*y3.*(15.*y1.^4+15.*y2.^4+(-80).*y2.^2.*y3.^2+48.* ...
                    y3.^4+10.*y1.^2.*(3.*y2.^2+(-8).*y3.^2)),@(y1,y2,y3)(-1/92160).*(y1+(sqrt(-1) ...
                    *(-1)).*y2).*(5.*y1.^6+5.*y2.^6+(-120).*y2.^4.*y3.^2+240.*y2.^2.* ...
                    y3.^4+(-64).*y3.^6+15.*y1.^4.*(y2.^2+(-8).*y3.^2)+15.*y1.^2.*( ...
                    y2.^4+(-16).*y2.^2.*y3.^2+16.*y3.^4)),@(y1,y2,y3)(1/80640).*y3.*((-35).* ...
                    y1.^6+(-35).*y2.^6+210.*y2.^4.*y3.^2+(-168).*y2.^2.*y3.^4+16.* ...
                    y3.^6+(-105).*y1.^4.*(y2.^2+(-2).*y3.^2)+(-21).*y1.^2.*(5.*y2.^4+( ...
                    -20).*y2.^2.*y3.^2+8.*y3.^4)),@(y1,y2,y3)(1/92160).*(y1+sqrt(-1).*y2).*(5.* ...
                    y1.^6+5.*y2.^6+(-120).*y2.^4.*y3.^2+240.*y2.^2.*y3.^4+(-64).* ...
                    y3.^6+15.*y1.^4.*(y2.^2+(-8).*y3.^2)+15.*y1.^2.*(y2.^4+(-16).* ...
                    y2.^2.*y3.^2+16.*y3.^4)),@(y1,y2,y3)(1/46080).*(y1+sqrt(-1).*y2).^2.*y3.*( ...
                    15.*y1.^4+15.*y2.^4+(-80).*y2.^2.*y3.^2+48.*y3.^4+10.*y1.^2.*(3.* ...
                    y2.^2+(-8).*y3.^2)),@(y1,y2,y3)(-1/92160).*(y1+sqrt(-1).*y2).^3.*(3.*y1.^4+ ...
                    3.*y2.^4+(-60).*y2.^2.*y3.^2+80.*y3.^4+6.*y1.^2.*(y2.^2+(-10).* ...
                    y3.^2)),@(y1,y2,y3)(-1/23040).*(y1+sqrt(-1).*y2).^4.*y3.*(3.*y1.^2+3.*y2.^2+( ...
                    -10).*y3.^2),@(y1,y2,y3)(1/92160).*(y1+sqrt(-1).*y2).^5.*(y1.^2+y2.^2+(-12).* ...
                    y3.^2),@(y1,y2,y3)(1/46080).*(y1+sqrt(-1).*y2).^6.*y3,@(y1,y2,y3)(-1/645120).*(y1+sqrt( ...
                    -1).*y2).^7,@(y1,y2,y3)(1/10321920).*(y1+(sqrt(-1)*(-1)).*y2).^8,@(y1,y2,y3)(1/645120).* ...
                    (y1+(sqrt(-1)*(-1)).*y2).^7.*y3,@(y1,y2,y3)(-1/1290240).*(y1+(sqrt(-1)*(-1)) ...
                    .*y2).^6.*(y1.^2+y2.^2+(-14).*y3.^2),@(y1,y2,y3)(-1/92160).*(y1+(sqrt(-1)*( ...
                    -1)).*y2).^5.*y3.*(y1.^2+y2.^2+(-4).*y3.^2),@(y1,y2,y3)(1/368640).*(y1+(sqrt( ...
                    -1)*(-1)).*y2).^4.*(y1.^4+y2.^4+(-24).*y2.^2.*y3.^2+40.*y3.^4+2.* ...
                    y1.^2.*(y2.^2+(-12).*y3.^2)),@(y1,y2,y3)(1/92160).*(y1+(sqrt(-1)*(-1)).*y2) ...
                    .^3.*y3.*(3.*y1.^4+3.*y2.^4+(-20).*y2.^2.*y3.^2+16.*y3.^4+y1.^2.*( ...
                    6.*y2.^2+(-20).*y3.^2)),@(y1,y2,y3)(-1/184320).*(y1+(sqrt(-1)*(-1)).*y2).^2.* ...
                    (y1.^6+y2.^6+(-30).*y2.^4.*y3.^2+80.*y2.^2.*y3.^4+(-32).*y3.^6+3.* ...
                    y1.^4.*(y2.^2+(-10).*y3.^2)+y1.^2.*(3.*y2.^4+(-60).*y2.^2.*y3.^2+ ...
                    80.*y3.^4)),@(y1,y2,y3)(-1/645120).*(y1+(sqrt(-1)*(-1)).*y2).*y3.*(35.*y1.^6+ ...
                    35.*y2.^6+(-280).*y2.^4.*y3.^2+336.*y2.^2.*y3.^4+(-64).*y3.^6+35.* ...
                    y1.^4.*(3.*y2.^2+(-8).*y3.^2)+7.*y1.^2.*(15.*y2.^4+(-80).*y2.^2.* ...
                    y3.^2+48.*y3.^4)),@(y1,y2,y3)(1/5160960).*(35.*y1.^8+35.*y2.^8+(-1120).* ...
                    y2.^6.*y3.^2+3360.*y2.^4.*y3.^4+(-1792).*y2.^2.*y3.^6+128.*y3.^8+ ...
                    140.*y1.^6.*(y2.^2+(-8).*y3.^2)+210.*y1.^4.*(y2.^4+(-16).*y2.^2.* ...
                    y3.^2+16.*y3.^4)+28.*y1.^2.*(5.*y2.^6+(-120).*y2.^4.*y3.^2+240.* ...
                    y2.^2.*y3.^4+(-64).*y3.^6)),@(y1,y2,y3)(1/645120).*(y1+sqrt(-1).*y2).*y3.*( ...
                    35.*y1.^6+35.*y2.^6+(-280).*y2.^4.*y3.^2+336.*y2.^2.*y3.^4+(-64).* ...
                    y3.^6+35.*y1.^4.*(3.*y2.^2+(-8).*y3.^2)+7.*y1.^2.*(15.*y2.^4+(-80) ...
                    .*y2.^2.*y3.^2+48.*y3.^4)),@(y1,y2,y3)(-1/184320).*(y1+sqrt(-1).*y2).^2.*( ...
                    y1.^6+y2.^6+(-30).*y2.^4.*y3.^2+80.*y2.^2.*y3.^4+(-32).*y3.^6+3.* ...
                    y1.^4.*(y2.^2+(-10).*y3.^2)+y1.^2.*(3.*y2.^4+(-60).*y2.^2.*y3.^2+ ...
                    80.*y3.^4)),@(y1,y2,y3)(-1/92160).*(y1+sqrt(-1).*y2).^3.*y3.*(3.*y1.^4+3.* ...
                    y2.^4+(-20).*y2.^2.*y3.^2+16.*y3.^4+y1.^2.*(6.*y2.^2+(-20).*y3.^2) ...
                    ),@(y1,y2,y3)(1/368640).*(y1+sqrt(-1).*y2).^4.*(y1.^4+y2.^4+(-24).*y2.^2.* ...
                    y3.^2+40.*y3.^4+2.*y1.^2.*(y2.^2+(-12).*y3.^2)),@(y1,y2,y3)(1/92160).*(y1+ ...
                    sqrt(-1).*y2).^5.*y3.*(y1.^2+y2.^2+(-4).*y3.^2),@(y1,y2,y3)(-1/1290240).*(y1+ ...
                    sqrt(-1).*y2).^6.*(y1.^2+y2.^2+(-14).*y3.^2),@(y1,y2,y3)(-1/645120).*(y1+ ...
                    sqrt(-1).*y2).^7.*y3,@(y1,y2,y3)(1/10321920).*(y1+sqrt(-1).*y2).^8,@(y1,y2,y3)( ...
                    1/185794560).*(y1+(sqrt(-1)*(-1)).*y2).^9,@(y1,y2,y3)(1/10321920).*(y1+(sqrt( ...
                    -1)*(-1)).*y2).^8.*y3,@(y1,y2,y3)(-1/20643840).*(y1+(sqrt(-1)*(-1)).*y2).^7.* ...
                    (y1.^2+y2.^2+(-16).*y3.^2),@(y1,y2,y3)(-1/3870720).*(y1+(sqrt(-1)*(-1)).*y2) ...
                    .^6.*y3.*(3.*y1.^2+3.*y2.^2+(-14).*y3.^2),@(y1,y2,y3)(1/5160960).*(y1+(sqrt( ...
                    -1)*(-1)).*y2).^5.*(y1.^4+y2.^4+(-28).*y2.^2.*y3.^2+56.*y3.^4+2.* ...
                    y1.^2.*(y2.^2+(-14).*y3.^2)),@(y1,y2,y3)(1/368640).*(y1+(sqrt(-1)*(-1)).*y2) ...
                    .^4.*y3.*(y1.^4+y2.^4+(-8).*y2.^2.*y3.^2+8.*y3.^4+2.*y1.^2.*( ...
                    y2.^2+(-4).*y3.^2)),@(y1,y2,y3)(-1/2211840).*(y1+(sqrt(-1)*(-1)).*y2).^3.*( ...
                    y1.^6+y2.^6+(-36).*y2.^4.*y3.^2+120.*y2.^2.*y3.^4+(-64).*y3.^6+3.* ...
                    y1.^4.*(y2.^2+(-12).*y3.^2)+3.*y1.^2.*(y2.^4+(-24).*y2.^2.*y3.^2+ ...
                    40.*y3.^4)),@(y1,y2,y3)(-1/1290240).*(y1+(sqrt(-1)*(-1)).*y2).^2.*y3.*(7.* ...
                    y1.^6+7.*y2.^6+(-70).*y2.^4.*y3.^2+112.*y2.^2.*y3.^4+(-32).*y3.^6+ ...
                    7.*y1.^4.*(3.*y2.^2+(-10).*y3.^2)+7.*y1.^2.*(3.*y2.^4+(-20).* ...
                    y2.^2.*y3.^2+16.*y3.^4)),@(y1,y2,y3)(1/10321920).*(y1+(sqrt(-1)*(-1)).*y2).*( ...
                    7.*y1.^8+7.*y2.^8+(-280).*y2.^6.*y3.^2+1120.*y2.^4.*y3.^4+(-896).* ...
                    y2.^2.*y3.^6+128.*y3.^8+28.*y1.^6.*(y2.^2+(-10).*y3.^2)+14.* ...
                    y1.^4.*(3.*y2.^4+(-60).*y2.^2.*y3.^2+80.*y3.^4)+28.*y1.^2.*(y2.^6+ ...
                    (-30).*y2.^4.*y3.^2+80.*y2.^2.*y3.^4+(-32).*y3.^6)),@(y1,y2,y3)(1/46448640).* ...
                    y3.*(315.*y1.^8+315.*y2.^8+(-3360).*y2.^6.*y3.^2+6048.*y2.^4.* ...
                    y3.^4+(-2304).*y2.^2.*y3.^6+128.*y3.^8+420.*y1.^6.*(3.*y2.^2+(-8) ...
                    .*y3.^2)+126.*y1.^4.*(15.*y2.^4+(-80).*y2.^2.*y3.^2+48.*y3.^4)+ ...
                    36.*y1.^2.*(35.*y2.^6+(-280).*y2.^4.*y3.^2+336.*y2.^2.*y3.^4+(-64) ...
                    .*y3.^6)),@(y1,y2,y3)(-1/10321920).*(y1+sqrt(-1).*y2).*(7.*y1.^8+7.*y2.^8+( ...
                    -280).*y2.^6.*y3.^2+1120.*y2.^4.*y3.^4+(-896).*y2.^2.*y3.^6+128.* ...
                    y3.^8+28.*y1.^6.*(y2.^2+(-10).*y3.^2)+14.*y1.^4.*(3.*y2.^4+(-60).* ...
                    y2.^2.*y3.^2+80.*y3.^4)+28.*y1.^2.*(y2.^6+(-30).*y2.^4.*y3.^2+80.* ...
                    y2.^2.*y3.^4+(-32).*y3.^6)),@(y1,y2,y3)(-1/1290240).*(y1+sqrt(-1).*y2).^2.* ...
                    y3.*(7.*y1.^6+7.*y2.^6+(-70).*y2.^4.*y3.^2+112.*y2.^2.*y3.^4+(-32) ...
                    .*y3.^6+7.*y1.^4.*(3.*y2.^2+(-10).*y3.^2)+7.*y1.^2.*(3.*y2.^4+( ...
                    -20).*y2.^2.*y3.^2+16.*y3.^4)),@(y1,y2,y3)(1/2211840).*(y1+sqrt(-1).*y2).^3.* ...
                    (y1.^6+y2.^6+(-36).*y2.^4.*y3.^2+120.*y2.^2.*y3.^4+(-64).*y3.^6+ ...
                    3.*y1.^4.*(y2.^2+(-12).*y3.^2)+3.*y1.^2.*(y2.^4+(-24).*y2.^2.* ...
                    y3.^2+40.*y3.^4)),@(y1,y2,y3)(1/368640).*(y1+sqrt(-1).*y2).^4.*y3.*(y1.^4+ ...
                    y2.^4+(-8).*y2.^2.*y3.^2+8.*y3.^4+2.*y1.^2.*(y2.^2+(-4).*y3.^2)),@(y1,y2,y3)( ...
                    -1/5160960).*(y1+sqrt(-1).*y2).^5.*(y1.^4+y2.^4+(-28).*y2.^2.* ...
                    y3.^2+56.*y3.^4+2.*y1.^2.*(y2.^2+(-14).*y3.^2)),@(y1,y2,y3)(-1/3870720).*(y1+ ...
                    sqrt(-1).*y2).^6.*y3.*(3.*y1.^2+3.*y2.^2+(-14).*y3.^2),@(y1,y2,y3)( ...
                    1/20643840).*(y1+sqrt(-1).*y2).^7.*(y1.^2+y2.^2+(-16).*y3.^2),@(y1,y2,y3)( ...
                    1/10321920).*(y1+sqrt(-1).*y2).^8.*y3,@(y1,y2,y3)(-1/185794560).*(y1+sqrt(-1) ...
                    .*y2).^9,@(y1,y2,y3)(1/3715891200).*(y1+(sqrt(-1)*(-1)).*y2).^10,@(y1,y2,y3)( ...
                    1/185794560).*(y1+(sqrt(-1)*(-1)).*y2).^9.*y3,@(y1,y2,y3)(-1/371589120).*(y1+ ...
                    (sqrt(-1)*(-1)).*y2).^8.*(y1.^2+y2.^2+(-18).*y3.^2),@(y1,y2,y3)(-1/61931520) ...
                    .*(y1+(sqrt(-1)*(-1)).*y2).^7.*y3.*(3.*y1.^2+3.*y2.^2+(-16).* ...
                    y3.^2),@(y1,y2,y3)(1/247726080).*(y1+(sqrt(-1)*(-1)).*y2).^6.*(3.*y1.^4+3.* ...
                    y2.^4+(-96).*y2.^2.*y3.^2+224.*y3.^4+6.*y1.^2.*(y2.^2+(-16).* ...
                    y3.^2)),@(y1,y2,y3)(1/77414400).*(y1+(sqrt(-1)*(-1)).*y2).^5.*y3.*(15.*y1.^4+ ...
                    15.*y2.^4+(-140).*y2.^2.*y3.^2+168.*y3.^4+10.*y1.^2.*(3.*y2.^2+( ...
                    -14).*y3.^2)),@(y1,y2,y3)(-1/30965760).*(y1+(sqrt(-1)*(-1)).*y2).^4.*(y1.^6+ ...
                    y2.^6+(-42).*y2.^4.*y3.^2+168.*y2.^2.*y3.^4+(-112).*y3.^6+3.* ...
                    y1.^4.*(y2.^2+(-14).*y3.^2)+3.*y1.^2.*(y2.^4+(-28).*y2.^2.*y3.^2+ ...
                    56.*y3.^4)),@(y1,y2,y3)(-1/15482880).*(y1+(sqrt(-1)*(-1)).*y2).^3.*y3.*(7.* ...
                    y1.^6+7.*y2.^6+(-84).*y2.^4.*y3.^2+168.*y2.^2.*y3.^4+(-64).*y3.^6+ ...
                    21.*y1.^4.*(y2.^2+(-4).*y3.^2)+21.*y1.^2.*(y2.^4+(-8).*y2.^2.* ...
                    y3.^2+8.*y3.^4)),@(y1,y2,y3)(1/123863040).*(y1+(sqrt(-1)*(-1)).*y2).^2.*(7.* ...
                    y1.^8+7.*y2.^8+(-336).*y2.^6.*y3.^2+1680.*y2.^4.*y3.^4+(-1792).* ...
                    y2.^2.*y3.^6+384.*y3.^8+28.*y1.^6.*(y2.^2+(-12).*y3.^2)+42.* ...
                    y1.^4.*(y2.^4+(-24).*y2.^2.*y3.^2+40.*y3.^4)+28.*y1.^2.*(y2.^6+( ...
                    -36).*y2.^4.*y3.^2+120.*y2.^2.*y3.^4+(-64).*y3.^6)),@(y1,y2,y3)(1/92897280).* ...
                    (y1+(sqrt(-1)*(-1)).*y2).*y3.*(63.*y1.^8+63.*y2.^8+(-840).*y2.^6.* ...
                    y3.^2+2016.*y2.^4.*y3.^4+(-1152).*y2.^2.*y3.^6+128.*y3.^8+84.* ...
                    y1.^6.*(3.*y2.^2+(-10).*y3.^2)+126.*y1.^4.*(3.*y2.^4+(-20).* ...
                    y2.^2.*y3.^2+16.*y3.^4)+36.*y1.^2.*(7.*y2.^6+(-70).*y2.^4.*y3.^2+ ...
                    112.*y2.^2.*y3.^4+(-32).*y3.^6)),@(y1,y2,y3)(1/928972800).*((-63).*y1.^10+( ...
                    -63).*y2.^10+3150.*y2.^8.*y3.^2+(-16800).*y2.^6.*y3.^4+20160.* ...
                    y2.^4.*y3.^6+(-5760).*y2.^2.*y3.^8+256.*y3.^10+(-315).*y1.^8.*( ...
                    y2.^2+(-10).*y3.^2)+(-210).*y1.^6.*(3.*y2.^4+(-60).*y2.^2.*y3.^2+ ...
                    80.*y3.^4)+(-630).*y1.^4.*(y2.^6+(-30).*y2.^4.*y3.^2+80.*y2.^2.* ...
                    y3.^4+(-32).*y3.^6)+(-45).*y1.^2.*(7.*y2.^8+(-280).*y2.^6.*y3.^2+ ...
                    1120.*y2.^4.*y3.^4+(-896).*y2.^2.*y3.^6+128.*y3.^8)),@(y1,y2,y3)(-1/92897280) ...
                    .*(y1+sqrt(-1).*y2).*y3.*(63.*y1.^8+63.*y2.^8+(-840).*y2.^6.* ...
                    y3.^2+2016.*y2.^4.*y3.^4+(-1152).*y2.^2.*y3.^6+128.*y3.^8+84.* ...
                    y1.^6.*(3.*y2.^2+(-10).*y3.^2)+126.*y1.^4.*(3.*y2.^4+(-20).* ...
                    y2.^2.*y3.^2+16.*y3.^4)+36.*y1.^2.*(7.*y2.^6+(-70).*y2.^4.*y3.^2+ ...
                    112.*y2.^2.*y3.^4+(-32).*y3.^6)),@(y1,y2,y3)(1/123863040).*(y1+sqrt(-1).*y2) ...
                    .^2.*(7.*y1.^8+7.*y2.^8+(-336).*y2.^6.*y3.^2+1680.*y2.^4.*y3.^4+( ...
                    -1792).*y2.^2.*y3.^6+384.*y3.^8+28.*y1.^6.*(y2.^2+(-12).*y3.^2)+ ...
                    42.*y1.^4.*(y2.^4+(-24).*y2.^2.*y3.^2+40.*y3.^4)+28.*y1.^2.*( ...
                    y2.^6+(-36).*y2.^4.*y3.^2+120.*y2.^2.*y3.^4+(-64).*y3.^6)),@(y1,y2,y3)( ...
                    1/15482880).*(y1+sqrt(-1).*y2).^3.*y3.*(7.*y1.^6+7.*y2.^6+(-84).* ...
                    y2.^4.*y3.^2+168.*y2.^2.*y3.^4+(-64).*y3.^6+21.*y1.^4.*(y2.^2+(-4) ...
                    .*y3.^2)+21.*y1.^2.*(y2.^4+(-8).*y2.^2.*y3.^2+8.*y3.^4)),@(y1,y2,y3)( ...
                    -1/30965760).*(y1+sqrt(-1).*y2).^4.*(y1.^6+y2.^6+(-42).*y2.^4.* ...
                    y3.^2+168.*y2.^2.*y3.^4+(-112).*y3.^6+3.*y1.^4.*(y2.^2+(-14).* ...
                    y3.^2)+3.*y1.^2.*(y2.^4+(-28).*y2.^2.*y3.^2+56.*y3.^4)),@(y1,y2,y3)( ...
                    -1/77414400).*(y1+sqrt(-1).*y2).^5.*y3.*(15.*y1.^4+15.*y2.^4+( ...
                    -140).*y2.^2.*y3.^2+168.*y3.^4+10.*y1.^2.*(3.*y2.^2+(-14).*y3.^2)) ...
                    ,@(y1,y2,y3)(1/247726080).*(y1+sqrt(-1).*y2).^6.*(3.*y1.^4+3.*y2.^4+(-96).* ...
                    y2.^2.*y3.^2+224.*y3.^4+6.*y1.^2.*(y2.^2+(-16).*y3.^2)),@(y1,y2,y3)( ...
                    1/61931520).*(y1+sqrt(-1).*y2).^7.*y3.*(3.*y1.^2+3.*y2.^2+(-16).* ...
                    y3.^2),@(y1,y2,y3)(-1/371589120).*(y1+sqrt(-1).*y2).^8.*(y1.^2+y2.^2+(-18).* ...
                    y3.^2),@(y1,y2,y3)(-1/185794560).*(y1+sqrt(-1).*y2).^9.*y3,@(y1,y2,y3)(1/3715891200).*( ...
                    y1+sqrt(-1).*y2).^10};
            end
            out = Table{pos}(y1,y2,y3);
        end
        % Gauss points for triangle
        function [X,Y,Wx,Wy] = triQuad(this,n)
            N = this.ng;
            if nargin > 1
                N = n;
            end
            v = [0 0; 0 1; 1 0];
            n=1:N;  nnk=2*n+1; A=[1/3 repmat(1,1,N)./(nnk.*(nnk+2))];
            n=2:N; nnk=nnk(n); B1=2/9; nk=n+1; nnk2=nnk.*nnk;
            B=4*(n.*nk).^2./(nnk2.*nnk2-nnk2); ab=[A' [2; B1; B']]; s=sqrt(ab(2:N,2));
            [V,X]=eig(diag(ab(1:N,1),0)+diag(s,-1)+diag(s,1));
            [X,I]=sort(diag(X)); x=(X+1)/2; wx=ab(1,2)*V(1,I)'.^2/4;
            N=N-1; N1=N+1; N2=N+2;  y=cos((2*(N:-1:0)'+1)*pi/(2*N+2));
            L=zeros(N1,N2);  y0=2;  iter=0;
            while max(abs(y-y0))>eps
                L(:,1)=1;    L(:,2)=y;
                for k=2:N1
                    L(:,k+1)=( (2*k-1)*y.*L(:,k)-(k-1)*L(:,k-1) )/k;
                end
                Lp=(N2)*( L(:,N1)-y.*L(:,N2) )./(1-y.^2);
                y0=y;    y=y0-L(:,N2)./Lp;  iter=iter+1;
            end
            cd=[ 1, 0, 0; -1, 0, 1; 0, 1,-1]*v;
            t=(1+y)/2;  Wx=abs(det(cd(2:3,:)))*wx;  Wy=1./((1-y.^2).*Lp.^2)*(N2/N1)^2;
            [tt,xx]=meshgrid(t,x); yy=tt.*xx;
            X=cd(1,1)+cd(2,1)*xx+cd(3,1)*yy;    Y=cd(1,2)+cd(2,2)*xx+cd(3,2)*yy;
        end
    end
    methods(Static)
        function out = indexNM(n,m)
            mtot = 2*(n) + 1;
            mvirtual = m + (mtot - 1)/2  + 1;
            if ( mvirtual > mtot || mvirtual < 1)
                out = 0;
                return;
            end
            %Convert the n,m index to a position at a row vector Mnm
            a1 = 1;
            an = 2*(n-1)+1;
            totN = (a1 + an)*(n)/2;
            out = totN + mvirtual;
        end
    end
end